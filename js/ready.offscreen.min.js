ready(() => {
  // function handleIntersection(entries) {
  //   entries.map((entry) => {
  //     if (entry.isIntersecting) {
  //       var remove = [];
  //       for (var i=0; i<entry.target.classList.length; i++) {
  //         var cls = entry.target.classList[i];
  //         if (cls.indexOf('enter:') === 0) {
  //           remove.push(cls)
  //         }
  //       }
  //       for (var i=0; i<remove.length; i++) {
  //         entry.target.classList.remove(remove[i])
  //       }
  //     }
  //   });
  // }
  // const observer = new IntersectionObserver(handleIntersection,{
  //   threshold: 0.1,
  // });
  const elements = document.querySelectorAll('[class*="offscreen:"]');
  if (!elements) return;
  const getProgress = (start, end, progress) => {
    return start.map((value, index) => {
      return value + (end[index] - value) * progress;
    });
  }
  const getTrigger = (element) => {
    const trigger = element.getAttribute('data-trigger');
    switch(trigger) {
      case 'section':
        // while(element.parentNode.tagName !== 'BODY') {
        //   element = element.parentNode;
        // }
        // return element;
      default: return element;
    }
  }
  const animations = [];
  elements.forEach((el)=> {
    const offscreenClasses = [...el.classList].filter(className => className.startsWith('offscreen'));
    const offscreenStyle = window.getComputedStyle(el);
    const is3d = offscreenStyle.transform.startsWith('matrix3d');
    const offscreen = {
      transform: offscreenStyle.transform.slice(is3d ? 9 : 7, -1).split(', ').map(parseFloat),
      opacity: parseFloat(offscreenStyle.opacity),
    }
    el.classList.remove(...offscreenClasses);
    const onscreenStyle = window.getComputedStyle(el);
    animations.push({
      element: el,
      trigger: getTrigger(el),
      startProgress: parseFloat(el.getAttribute('data-start') || 0),
      endProgress: parseFloat(el.getAttribute('data-end') || 1),
      offscreenClasses: offscreenClasses,
      offscreen: offscreen,
      onscreen:{
        transform: onscreenStyle.transform.slice(is3d ? 9 : 7, -1).split(', ').map(parseFloat),
        opacity: parseFloat(onscreenStyle.opacity),
      },
    });
    //el.classList.remove(...offscreenClasses);
  });
  const getOffsetTop = (element) => {
    let offsetTop  = 0;
    do{
        offsetTop  += element.offsetTop;
        element = element.offsetParent;
    } while( element );
    return offsetTop;
  }
  const updateAnimations = () => { 
    animations.forEach(anim => {
      const rect = anim.trigger.getBoundingClientRect();
      const pixelsAboveBottom = window.innerHeight+window.scrollY-getOffsetTop(anim.trigger)
      const percentageOverBottom = Math.min(pixelsAboveBottom/anim.trigger.clientHeight,1.0);
      const progress = percentageOverBottom < anim.startProgress ? 0 : percentageOverBottom > anim.endProgress ? 1 : (percentageOverBottom-anim.startProgress)/(anim.endProgress-anim.startProgress);

      // if (percentageOverBottom > 0.2) {
      //   anim.element.classList.remove(...anim.offscreenClasses);
      // } else {
      //   anim.element.classList.add(...anim.offscreenClasses);
      // }

      // Scroll transform
      anim.element.style.transform = 'matrix'+(anim.onscreen.transform.length > 6 ? '3d' : '')+'('+getProgress(anim.offscreen.transform,anim.onscreen.transform,progress).join(', ')+')';
      anim.element.style.opacity = getProgress([anim.offscreen.opacity],[anim.onscreen.opacity],progress)[0];
    });
  };
  window.addEventListener('scroll', () => {
    updateAnimations();
  });
  updateAnimations();
  
});